<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Series Timeline</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    sans-serif;
                background: #1a1a2e;
                color: #eee;
                padding: 20px;
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
                color: #fff;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
            }

            .timeline {
                position: relative;
                padding: 20px 0;
            }

            .chart-wrapper {
                position: relative;
            }

            .chart-controls {
                position: absolute;
                top: 50px;
                right: 10px;
                z-index: 30;
                display: flex;
                gap: 10px;
                background: #0f0f23;
                padding: 8px;
                border-radius: 6px;
            }

            .control-group {
                display: flex;
                gap: 5px;
                align-items: center;
            }

            .control-group:not(:last-child) {
                padding-right: 10px;
                border-right: 1px solid #444;
            }

            .zoom-btn {
                width: 32px;
                height: 32px;
                border: 1px solid #444;
                background: #16213e;
                color: #fff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: background 0.2s;
            }

            .zoom-btn:hover {
                background: #1a1a2e;
            }

            .zoom-level {
                color: #888;
                font-size: 12px;
                display: flex;
                align-items: center;
                padding: 0 8px;
            }

            .toggle-label {
                display: flex;
                align-items: center;
                gap: 8px;
                color: #888;
                font-size: 12px;
                cursor: pointer;
            }

            .toggle-checkbox {
                width: 36px;
                height: 20px;
                appearance: none;
                background: #16213e;
                border: 1px solid #444;
                border-radius: 10px;
                cursor: pointer;
                position: relative;
                transition: background 0.2s;
            }

            .toggle-checkbox:checked {
                background: #4cc9f0;
                border-color: #4cc9f0;
            }

            .toggle-checkbox::before {
                content: "";
                position: absolute;
                width: 14px;
                height: 14px;
                background: #fff;
                border-radius: 50%;
                top: 2px;
                left: 2px;
                transition: transform 0.2s;
            }

            .toggle-checkbox:checked::before {
                transform: translateX(16px);
            }

            .chart-container {
                background: #16213e;
                border-radius: 8px;
                overflow-x: auto;
                max-height: 80vh;
                overflow-y: auto;
            }

            .chart {
                height: auto;
                position: relative;
            }

            .year-header {
                display: flex;
                position: sticky;
                top: 0;
                background: #16213e;
                z-index: 20;
                height: 40px;
                align-items: center;
            }

            .year-header-spacer {
                width: 250px;
                flex-shrink: 0;
                background: #16213e;
            }

            .year-header-timeline {
                flex: 1;
                position: relative;
                height: 100%;
                display: flex;
                align-items: center;
                padding-right: 100px;
            }

            .year-header-label {
                position: absolute;
                transform: translateX(-50%);
                font-size: 12px;
                color: rgba(255, 255, 255, 0.6);
                font-weight: bold;
            }

            .series-row {
                display: flex;
                align-items: center;
                margin-bottom: 5px;
                min-height: 40px;
            }

            .series-label {
                width: 250px;
                flex-shrink: 0;
                font-size: 14px;
                padding-right: 15px;
                text-align: right;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                position: sticky;
                left: 0;
                background: #16213e;
                z-index: 10;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: flex-end;
            }

            .series-timeline {
                flex: 1;
                position: relative;
                height: 40px;
                padding-right: 100px;
            }

            .episode {
                position: absolute;
                width: 14px;
                height: 14px;
                border-radius: 50%;
                transform: translate(-50%, -50%);
                top: 50%;
                cursor: pointer;
                transition:
                    transform 0.2s,
                    box-shadow 0.2s;
                border: 2px solid rgba(255, 255, 255, 0.3);
            }

            .episode:hover {
                transform: translate(-50%, -50%) scale(1.5);
                box-shadow: 0 0 15px currentColor;
                z-index: 100;
            }

            .series-line {
                position: absolute;
                height: 3px;
                top: 50%;
                transform: translateY(-50%);
                border-radius: 2px;
                opacity: 0.5;
            }

            .year-lines {
                position: absolute;
                top: 0;
                left: 250px;
                right: 100px;
                bottom: 0;
                pointer-events: none;
            }

            .year-line {
                position: absolute;
                top: 0;
                bottom: 0;
                width: 1px;
                background: rgba(255, 255, 255, 0.1);
            }

            .year-line-label {
                display: none;
            }

            .tooltip {
                position: fixed;
                background: #0f0f23;
                border: 1px solid #444;
                padding: 12px;
                border-radius: 8px;
                font-size: 13px;
                max-width: 400px;
                pointer-events: none;
                z-index: 1000;
                display: none;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            }

            .tooltip-thumbnail {
                width: 150px;
                border-radius: 4px;
                margin-bottom: 10px;
            }

            .tooltip-title {
                font-weight: bold;
                margin-bottom: 8px;
                color: #fff;
                line-height: 1.3;
            }

            .tooltip-meta {
                display: flex;
                flex-wrap: wrap;
                gap: 8px 16px;
                margin-bottom: 8px;
                color: #aaa;
                font-size: 12px;
            }

            .tooltip-meta span {
                display: flex;
                align-items: center;
                gap: 4px;
            }

            .tooltip-description {
                color: #888;
                font-size: 12px;
                line-height: 1.4;
                max-height: 120px;
                overflow: hidden;
                text-overflow: ellipsis;
                display: -webkit-box;
                -webkit-line-clamp: 6;
                -webkit-box-orient: vertical;
            }

            .stats {
                margin-bottom: 30px;
                padding: 15px;
                background: #16213e;
                border-radius: 8px;
            }

            .stats h3 {
                margin-bottom: 15px;
            }

            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
            }

            .stat-card {
                background: #1a1a2e;
                padding: 15px;
                border-radius: 6px;
            }

            .stat-value {
                font-size: 24px;
                font-weight: bold;
                color: #4cc9f0;
            }

            .stat-label {
                font-size: 12px;
                color: #888;
                margin-top: 5px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>2d6+Cool - Series Timeline</h1>

            <div class="stats" id="stats"></div>

            <div class="chart-wrapper">
                <div class="chart-controls">
                    <div class="control-group">
                        <button class="zoom-btn" id="zoomOut">‚àí</button>
                        <span class="zoom-level" id="zoomLevel">100%</span>
                        <button class="zoom-btn" id="zoomIn">+</button>
                        <button class="zoom-btn" id="zoomReset">‚Ü∫</button>
                    </div>
                    <div class="control-group">
                        <label class="toggle-label">
                            <input
                                type="checkbox"
                                class="toggle-checkbox"
                                id="viewSizeToggle"
                                checked
                            />
                            Size by views
                        </label>
                    </div>
                </div>
                <div class="chart-container" id="chartContainer">
                    <div class="year-header" id="yearHeader"></div>
                    <div class="chart" id="chart"></div>
                </div>
            </div>
        </div>

        <div class="tooltip" id="tooltip"></div>

        <script>
            // Color palette for series
            const colors = [
                "#e63946",
                "#f4a261",
                "#2a9d8f",
                "#264653",
                "#e9c46a",
                "#9b59b6",
                "#3498db",
                "#1abc9c",
                "#e74c3c",
                "#f39c12",
                "#8e44ad",
                "#2980b9",
                "#27ae60",
                "#d35400",
                "#c0392b",
                "#16a085",
                "#8e44ad",
                "#2c3e50",
                "#f1c40f",
                "#e67e22",
                "#9b59b6",
                "#1abc9c",
                "#34495e",
                "#e91e63",
                "#00bcd4",
                "#4caf50",
                "#ff9800",
                "#795548",
                "#607d8b",
                "#3f51b5",
            ];

            let videosData = null;
            let zoomLevel = 1;
            let sizeByViews = true;
            const minZoom = 0.5;
            const maxZoom = 4;
            const baseWidth = 2500;
            const minCircleSize = 6;
            const maxCircleSize = 40;

            function updateZoom() {
                const width = baseWidth * zoomLevel;
                document.getElementById("chart").style.minWidth = width + "px";
                document.getElementById("yearHeader").style.minWidth =
                    width + "px";
                document.getElementById("zoomLevel").textContent =
                    Math.round(zoomLevel * 100) + "%";
            }

            function setupZoomControls() {
                const chartContainer =
                    document.getElementById("chartContainer");

                document
                    .getElementById("zoomIn")
                    .addEventListener("click", () => {
                        zoomLevel = Math.min(maxZoom, zoomLevel * 1.25);
                        updateZoom();
                    });

                document
                    .getElementById("zoomOut")
                    .addEventListener("click", () => {
                        zoomLevel = Math.max(minZoom, zoomLevel / 1.25);
                        updateZoom();
                    });

                document
                    .getElementById("zoomReset")
                    .addEventListener("click", () => {
                        zoomLevel = 1;
                        updateZoom();
                    });

                // Mouse wheel zoom with Ctrl/Cmd
                chartContainer.addEventListener(
                    "wheel",
                    (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            const scrollLeft = chartContainer.scrollLeft;
                            const mouseX =
                                e.clientX -
                                chartContainer.getBoundingClientRect().left +
                                scrollLeft;
                            const oldZoom = zoomLevel;

                            if (e.deltaY < 0) {
                                zoomLevel = Math.min(maxZoom, zoomLevel * 1.1);
                            } else {
                                zoomLevel = Math.max(minZoom, zoomLevel / 1.1);
                            }

                            updateZoom();

                            // Adjust scroll to keep mouse position stable
                            const newMouseX = mouseX * (zoomLevel / oldZoom);
                            chartContainer.scrollLeft =
                                newMouseX -
                                (e.clientX -
                                    chartContainer.getBoundingClientRect()
                                        .left);
                        }
                    },
                    { passive: false },
                );

                // Size by views toggle
                document
                    .getElementById("viewSizeToggle")
                    .addEventListener("change", (e) => {
                        sizeByViews = e.target.checked;
                        updateCircleSizes();
                    });
            }

            function updateCircleSizes() {
                const episodes = document.querySelectorAll(".episode");
                if (!videosData) return;

                const videos = videosData.videos;
                const maxViews = Math.max(
                    ...videos.map((v) => v.viewCount || 0),
                );
                const minViews = Math.min(
                    ...videos.map((v) => v.viewCount || 0),
                );
                const viewRange = maxViews - minViews || 1;

                episodes.forEach((ep) => {
                    const views = parseInt(ep.dataset.views) || 0;
                    let size;
                    if (sizeByViews) {
                        // Scale area proportionally to views
                        const normalized = (views - minViews) / viewRange;
                        const minArea =
                            Math.PI * Math.pow(minCircleSize / 2, 2);
                        const maxArea =
                            Math.PI * Math.pow(maxCircleSize / 2, 2);
                        const area = minArea + normalized * (maxArea - minArea);
                        size = 2 * Math.sqrt(area / Math.PI);
                    } else {
                        size = 14; // Default size
                    }
                    ep.style.width = size + "px";
                    ep.style.height = size + "px";
                });
            }

            async function loadData() {
                try {
                    const response = await fetch("./data/videos.json");
                    videosData = await response.json();
                    renderTimeline();
                    updateCircleSizes();
                } catch (error) {
                    console.error("Error loading data:", error);
                    document.getElementById("chart").innerHTML =
                        '<p style="padding: 20px;">Error loading videos.json. Make sure to serve this file from a web server.</p>';
                }
            }

            function renderTimeline() {
                const videos = videosData.videos;

                // Group videos by series
                const seriesMap = new Map();
                videos.forEach((video) => {
                    const serie = video.serie || "Unknown";
                    if (!seriesMap.has(serie)) {
                        seriesMap.set(serie, []);
                    }
                    seriesMap.get(serie).push(video);
                });

                // Sort series by first episode date
                const sortedSeries = Array.from(seriesMap.entries())
                    .map(([name, episodes]) => ({
                        name,
                        episodes: episodes.sort(
                            (a, b) =>
                                new Date(a.publishedAt) -
                                new Date(b.publishedAt),
                        ),
                    }))
                    .sort(
                        (a, b) =>
                            new Date(a.episodes[0].publishedAt) -
                            new Date(b.episodes[0].publishedAt),
                    );

                // Assign colors to series
                const seriesColors = new Map();
                sortedSeries.forEach((serie, index) => {
                    seriesColors.set(serie.name, colors[index % colors.length]);
                });

                // Find date range
                const allDates = videos.map((v) => new Date(v.publishedAt));
                const minDate = new Date(Math.min(...allDates));
                const maxDate = new Date(Math.max(...allDates));

                // Add some padding to the date range
                minDate.setMonth(minDate.getMonth() - 1);
                maxDate.setFullYear(maxDate.getFullYear() + 1);

                const totalMs = maxDate - minDate;

                // Generate year lines
                const years = [];
                const startYear = minDate.getFullYear();
                const endYear = maxDate.getFullYear();
                for (let year = startYear; year <= endYear; year++) {
                    const yearDate = new Date(year, 0, 1);
                    if (yearDate >= minDate && yearDate <= maxDate) {
                        const pos = ((yearDate - minDate) / totalMs) * 100;
                        years.push({ year, pos });
                    }
                }

                const yearLinesHtml = `
                    <div class="year-lines">
                        ${years
                            .map(
                                (y) => `
                            <div class="year-line" style="left: ${y.pos}%;">
                                <div class="year-line-label">${y.year}</div>
                            </div>
                        `,
                            )
                            .join("")}
                    </div>
                `;

                // Render sticky year header
                const yearHeaderEl = document.getElementById("yearHeader");
                yearHeaderEl.innerHTML = `
                    <div class="year-header-spacer"></div>
                    <div class="year-header-timeline">
                        ${years.map((y) => `<div class="year-header-label" style="left: ${y.pos}%;">${y.year}</div>`).join("")}
                    </div>
                `;

                // Render chart
                const chartEl = document.getElementById("chart");
                chartEl.innerHTML =
                    yearLinesHtml +
                    sortedSeries
                        .map((serie) => {
                            const color = seriesColors.get(serie.name);
                            const episodes = serie.episodes;

                            // Calculate line position (from first to last episode)
                            const firstPos =
                                ((new Date(episodes[0].publishedAt) - minDate) /
                                    totalMs) *
                                100;
                            const lastPos =
                                ((new Date(
                                    episodes[episodes.length - 1].publishedAt,
                                ) -
                                    minDate) /
                                    totalMs) *
                                100;

                            const episodeCircles = episodes
                                .map((ep) => {
                                    const pos =
                                        ((new Date(ep.publishedAt) - minDate) /
                                            totalMs) *
                                        100;
                                    const thumbnail =
                                        ep.thumbnails?.medium?.url ||
                                        ep.thumbnails?.default?.url ||
                                        "";
                                    const description = (ep.description || "")
                                        .replace(/"/g, "&quot;")
                                        .replace(/\n/g, " ");
                                    return `<div class="episode"
            style="left: ${pos}%; background: ${color}; color: ${color};"
            data-title="${ep.title.replace(/"/g, "&quot;")}"
            data-date="${new Date(ep.publishedAt).toLocaleDateString("fr-FR", { year: "numeric", month: "long", day: "numeric" })}"
            data-duration="${ep.durationFormatted}"
            data-views="${ep.viewCount || 0}"
            data-likes="${ep.likeCount || 0}"
            data-comments="${ep.commentCount || 0}"
            data-thumbnail="${thumbnail}"
            data-description="${description}"
            data-url="${ep.url}"
            data-serie="${serie.name}"></div>`;
                                })
                                .join("");

                            return `
          <div class="series-row" data-serie="${serie.name}">
            <div class="series-label" title="${serie.name}">${serie.name}</div>
            <div class="series-timeline">
              <div class="series-line" style="left: ${firstPos}%; width: ${lastPos - firstPos}%; background: ${color};"></div>
              ${episodeCircles}
            </div>
          </div>
        `;
                        })
                        .join("");

                // Setup tooltip
                const tooltip = document.getElementById("tooltip");
                chartEl.querySelectorAll(".episode").forEach((ep) => {
                    ep.addEventListener("mouseenter", (e) => {
                        const thumbnailHtml = ep.dataset.thumbnail
                            ? `<img class="tooltip-thumbnail" src="${ep.dataset.thumbnail}" alt="">`
                            : "";
                        const descriptionHtml = ep.dataset.description
                            ? `<div class="tooltip-description">${ep.dataset.description}</div>`
                            : "";
                        tooltip.innerHTML = `
            ${thumbnailHtml}
            <div class="tooltip-title">${ep.dataset.title}</div>
            <div class="tooltip-meta">
              <span>üìÖ ${ep.dataset.date}</span>
              <span>‚è±Ô∏è ${ep.dataset.duration}</span>
              <span>üëÅÔ∏è ${Number(ep.dataset.views).toLocaleString()}</span>
              <span>üëç ${Number(ep.dataset.likes).toLocaleString()}</span>
              <span>üí¨ ${Number(ep.dataset.comments).toLocaleString()}</span>
            </div>
            ${descriptionHtml}
          `;
                        tooltip.style.display = "block";
                    });

                    ep.addEventListener("mousemove", (e) => {
                        const tooltipRect = tooltip.getBoundingClientRect();
                        const viewportWidth = window.innerWidth;
                        const viewportHeight = window.innerHeight;

                        let left = e.clientX + 15;
                        let top = e.clientY + 15;

                        // Adjust if tooltip overflows right edge
                        if (left + tooltipRect.width > viewportWidth) {
                            left = e.clientX - tooltipRect.width - 15;
                        }

                        // Adjust if tooltip overflows bottom edge
                        if (top + tooltipRect.height > viewportHeight) {
                            top = e.clientY - tooltipRect.height - 15;
                        }

                        // Ensure tooltip doesn't go off left or top edge
                        left = Math.max(10, left);
                        top = Math.max(10, top);

                        tooltip.style.left = left + "px";
                        tooltip.style.top = top + "px";
                    });

                    ep.addEventListener("mouseleave", () => {
                        tooltip.style.display = "none";
                    });

                    ep.addEventListener("click", () => {
                        window.open(ep.dataset.url, "_blank");
                    });
                });

                // Render stats
                const statsEl = document.getElementById("stats");
                const totalEpisodes = videos.length;
                const totalDuration = videos.reduce(
                    (sum, v) => sum + (v.durationSeconds || 0),
                    0,
                );
                const avgDuration = totalDuration / totalEpisodes;

                statsEl.innerHTML = `
        <h3>Statistics</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value">${sortedSeries.length}</div>
            <div class="stat-label">Series</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${totalEpisodes}</div>
            <div class="stat-label">Total Episodes</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${Math.floor(totalDuration / 3600)}h</div>
            <div class="stat-label">Total Duration</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${Math.floor(avgDuration / 60)}min</div>
            <div class="stat-label">Average Episode Duration</div>
          </div>
        </div>
      `;
            }

            loadData();
            setupZoomControls();
        </script>
    </body>
</html>
